<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NativeJS_1</title>
</head>
<body>
<script>
    //---
    // function resolveAfter2Seconds(x) {
    //     console.log(`${x}`)
    //
    //     return new Promise(resolve => {
    //         setTimeout(() => {
    //             resolve(x)
    //         }, 2000)
    //     })
    // }
    //
    // async function add1(x) {
    //     console.log('add1 Hello')
    //
    //     const a = await resolveAfter2Seconds(20);
    //
    //     const b = await resolveAfter2Seconds(30);
    //
    //     console.log('add1 Bye')
    //
    //     return x + a + b;
    // }
    //
    // add1(10).then(console.log);
    //Начинает выполняться функция add1(10) с аргументом 10. Регистрируется .then(console.log) в состоянии pending. Идем в тело функции add1, синхронно выполняется console.log('add1 Hello'), в консоль выводится'add1 Hello'. Затем объявляется константа a, в которой выполняется функция resolveAfter2Seconds(20) с аргументом 20. Следующая строчка с const b регистрирует промис в состоянии pending, т.е. ждет выполненения предыдущей строчки с await. Идем в resolveAfter2Seconds(20). Синхронно выполняется console.log(`${x}`), x берется из аргументов и в консоль выводится 20. Затем она возвращает новый промис, который тоже в состоянии pending. Дальше регистрируется setTimeout, он идет в webApi ждать делей 2 сек. Т.к. строчка const b... все еще ждет выполнения const a = await..., то идет задержка на 2 сек. Проходит 2 сек, коллбек () => {resolve(x)} попадает в очередь макротасок. Т.к. ни синхронного кода, ни микротасок нет, то этот коллбек выполняется, resolve переводит состояние промиса в fullfilled и в очередь микротасок падает этот промис. Т.к. синхронного кода и других микротасок нет, то он падает на стек и выполняентся, и в константу a присваивается значение 20. Затем возвращаемсяс в функцию add1, начинает выполняться строчка const b. Аналогично идем в resolveAfter2Seconds(30). Синхронно выполняется console.log(`${x}`), x берется из аргументов и в консоль выводится 30. Затем она возвращает новый промис, который регистрируется в состоянии pending. Там регистрируется setTimeout, он идет в webApi ждать делей 2 сек. Т.к. строчка console.log('add1 Bye') ждет выполнения вышестоящего await и синхронного кода больше нет, то возвращается новый промис, который регистрируется в состоянии pending. Далее регистрируется setTimeout, он идет в webApi ждать делей 2 сек. Т.к. строчка console.log('add1 Bye') все еще ждет выполнения const b = await..., то идет задержка на 2 сек. Проходит 2 сек, коллбек () => {resolve(x)} попадает в очередь макротасок. Там он резолвит промис, который попадает в очередь микротасок. Т.к. ни синхронного кода, ни микротасок нет, то на стекпадает присовение константе b значения 30. Затем возвращаемсяс в функцию add1, синхронно выполняется console.log('add1 Bye'), в консоль выводится 'add1 Bye'. Затем возвращается значение x + a + b, т.е. 10 + 20 + 30 или 60. Возвращаемся к add1(10).then(console.log), где .then(console.log) ?резолвится? и попадает в очередь микротасок. Т.к. синхронного кода больше нет и нет микротасок, то console.log падает на стек, а значение берется из return функции add(), т.е. в консоль выводится 60. Итого в консоли будет: 'add1 Hello' - 20 - delay 2 sec - 30 - delay 2 sec - 'add1 Bye' - 60
    //Можно уменьшить время выполнения на 2s если: 1) использовать Promise.all() 2) перенести await у каждой функции в return:
// 1) Promise.all()
//     async function add1(x) {
//         console.log('add1 Hello');
//
//         const [a, b] = await Promise.all([
//             resolveAfter2Seconds(20),
//             resolveAfter2Seconds(30)
//         ]);
//
//         console.log('add1 Bye');
//
//         return x + a + b;
//     }

    //Перенос await
    // function resolveAfter2Seconds(x) {
    //     console.log(`${x}`)
    //
    //     return new Promise(resolve => {
    //         setTimeout(() => {
    //             resolve(x)
    //         }, 2000)
    //     })
    // }
    //
    // async function add1(x) {
    //     console.log('add1 Hello')
    //
    //     const a = resolveAfter2Seconds(20);
    //
    //     const b = resolveAfter2Seconds(30);
    //
    //     console.log('add1 Bye')
    //
    //     return x + await a +  await b;
    // }
    //
    // add1(10).then(console.log);
    //---
//---
//     const func = () => {
//         const a = 1
//         const b = 2
//
//         return a, b
//     }
//
//     console.log(func())
//
//     Интерпретатор поймет как:
//     const func = () => {
//         const a = 1
//         const b = 2
//
//         a,
//         return b
//     }
//
//     console.log(func())
    //Т.к. запятая , - это специальный оператор, который позволяет выполнить несколько выражений, но вернёт результат только последнего из них.
//--------------------------------------------------------------------
//
//     const func = (a, b) => {
//         //a = ['hello ', ' World!']
//         //b = 3
//         return b
//     }
//
//     console.log(func`hello ${3} World!`)

    //Работа тегированных шаблоннхм строк (tagged template literals) в JavaScript.
    //func`hello ${3} World!` не то же самое, что func("hello 3 World!")
    //Он превращается в func(["hello ", " World!"], 3)
    //Первый аргумент — массив строковых литералов между ${...}: ["hello ", " World!"]
    //Остальные аргументы — значения выражений внутри ${...}: 3
</script>
</body>
</html>
